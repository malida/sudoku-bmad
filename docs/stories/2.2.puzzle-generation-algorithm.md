# Story 2.2: Puzzle Generation Algorithm

## Status

Ready for Review

## Story

**As a** developer,
**I want** an algorithm to generate valid Sudoku puzzles with unique solutions,
**so that** the application can create unlimited puzzles without hardcoded data.

## Acceptance Criteria

1. A generator function creates a valid, completely filled 9x9 Sudoku grid (solved puzzle)
2. The generator uses backtracking with randomized cell/number selection to ensure puzzle variety
3. The generator removes numbers from the solved grid to create the puzzle (leaving given clues)
4. The generator removes numbers strategically to achieve appropriate difficulty (approximately 40-50 clues remaining for MVP)
5. After each number removal, the generator verifies the puzzle still has a unique solution using the solver
6. If removing a number results in multiple solutions, that number is retained (not removed)
7. The generator completes within 2 seconds (per NFR1)
8. Generated puzzles are valid (all Sudoku rules satisfied in the solution)
9. Generated puzzles are solvable by the solver
10. Generated puzzles have exactly one unique solution

## Tasks / Subtasks

- [x] Implement helper function: shuffleArray(array) (AC: 2)
  - [x] Use Fisher-Yates shuffle algorithm for true randomization
  - [x] Modify array in place
  - [x] Return the shuffled array
  - [x] Add JSDoc documentation

- [x] Implement helper function: getAllCellCoordinates() (AC: 3)
  - [x] Generate array of all 81 cell coordinates: `[{row: 0, col: 0}, {row: 0, col: 1}, ..., {row: 8, col: 8}]`
  - [x] Use nested loops (row 0-8, col 0-8)
  - [x] Return array of 81 coordinate objects
  - [x] Add JSDoc documentation

- [x] Implement generateSolvedGrid() function (AC: 1, 2, 8)
  - [x] Create empty 9x9 grid: `Array.from({ length: 9 }, () => Array(9).fill(0))`
  - [x] Implement fillGrid(grid) recursive helper using backtracking
  - [x] Find empty cell using findEmptyCell() from Story 2.1
  - [x] Create array [1,2,3,4,5,6,7,8,9] and shuffle it with shuffleArray()
  - [x] Try each number in shuffled order
  - [x] Use isValidPlacement() from Story 2.1 to check validity
  - [x] Place number and recursively call fillGrid()
  - [x] If successful, return true; if not, backtrack (set cell to 0)
  - [x] Return the filled grid once complete
  - [x] Add JSDoc documentation explaining randomization approach

- [x] Implement main generatePuzzle() function (AC: 3, 4, 5, 6, 7, 10)
  - [x] Step 1: Generate complete solved grid using generateSolvedGrid()
  - [x] Step 2: Deep copy solved grid: `JSON.parse(JSON.stringify(solvedGrid))`
  - [x] Step 3: Get all cell coordinates and shuffle using getAllCellCoordinates() + shuffleArray()
  - [x] Step 4: Define target clues constant: `const TARGET_CLUES = 45;`
  - [x] Step 5: Initialize clues counter: `let cluesRemaining = 81;`
  - [x] Step 6: Loop through shuffled cell coordinates
  - [x] Step 7: For each cell, if cluesRemaining <= TARGET_CLUES, break (target reached)
  - [x] Step 8: Store cell value temporarily: `const removedValue = puzzleGrid[row][col];`
  - [x] Step 9: Set cell to 0: `puzzleGrid[row][col] = 0;`
  - [x] Step 10: Check uniqueness using hasUniqueSolution() from Story 2.1
  - [x] Step 11: If unique solution still exists, keep removal (decrement cluesRemaining)
  - [x] Step 12: If multiple solutions exist, restore value: `puzzleGrid[row][col] = removedValue;`
  - [x] Step 13: Return the generated puzzle grid
  - [x] Add JSDoc documentation with algorithm explanation

- [x] Export generatePuzzle() as public API (AC: 1, 8, 9, 10)
  - [x] Add export statement: `export function generatePuzzle() { ... }`
  - [x] Ensure generateSolvedGrid() remains internal (not exported)
  - [x] Keep helper functions internal (shuffleArray, getAllCellCoordinates)

- [x] Add error handling and timeout protection (AC: 7)
  - [x] Wrap generatePuzzle() in try-catch
  - [x] Add timeout mechanism: track start time, check elapsed time periodically
  - [x] If generation exceeds 2 seconds, throw error with message: "Puzzle generation timed out"
  - [x] Provide fallback suggestion in error message or comments

- [x] Manual testing and validation (AC: 1, 7, 8, 9, 10)
  - [x] Test 1: Generate 5 puzzles and verify each completes within 2 seconds
  - [x] Test 2: Verify each generated puzzle has ~40-50 given clues (count non-zero cells)
  - [x] Test 3: Verify generated puzzles are different (compare grids)
  - [x] Test 4: Verify each puzzle is solvable using solvePuzzle() from Story 2.1
  - [x] Test 5: Verify each puzzle has unique solution using hasUniqueSolution() from Story 2.1
  - [x] Test 6: Verify solved grid is valid (no rule violations in complete grid)
  - [x] Test 7: Performance benchmark - measure average generation time over 10 puzzles
  - [x] Document test results in Dev Agent Record section

## Dev Notes

### Architecture Context

**Depends on:** Story 2.1 (requires solvePuzzle(), hasUniqueSolution(), isValidPlacement(), findEmptyCell())

**Previous Story Insights:**
Story 2.1 implemented the backtracking solver in `scripts/generator.js` with:
- `solvePuzzle(grid)` - Solves puzzles using backtracking
- `hasUniqueSolution(grid)` - Verifies exactly one solution exists
- `countSolutions(grid, maxCount)` - Counts solutions with early exit
- `isValidPlacement(grid, row, col, num)` - Internal helper for validation
- `findEmptyCell(grid)` - Internal helper to find next empty cell

Story 2.2 will extend the same `generator.js` module with puzzle generation functions.

**File Location:**
Add functions to existing `scripts/generator.js` module created in Story 2.1.
[Source: architecture/source-tree.md#scripts-directory]

**Module Structure:**
```javascript
// generator.js - updated structure after Story 2.2
import { validateGrid } from './validation.js';

// Internal helpers from Story 2.1
function findEmptyCell(grid) { /* ... */ }
function isValidPlacement(grid, row, col, num) { /* ... */ }

// Story 2.1 public API
export function solvePuzzle(grid) { /* ... */ }
export function countSolutions(grid, maxCount) { /* ... */ }
export function hasUniqueSolution(grid) { /* ... */ }

// NEW Story 2.2 internal helpers
function shuffleArray(array) { /* ... */ }
function getAllCellCoordinates() { /* ... */ }
function generateSolvedGrid() { /* ... */ }

// NEW Story 2.2 public API
export function generatePuzzle() { /* ... */ }
```
[Source: architecture/source-tree.md#module-dependencies]

**Algorithm Implementation:**
The puzzle generation algorithm follows a two-phase approach:

**Phase 1: Generate Solved Grid**
- Start with empty 9x9 grid (all zeros)
- Use backtracking with randomized number selection
- Shuffle numbers 1-9 before trying each cell
- This ensures variety in generated puzzles
- Same backtracking logic as solver, but with randomization

**Phase 2: Remove Numbers Strategically**
- Start with complete solved grid (81 filled cells)
- Get all 81 cell coordinates and shuffle randomly
- Try removing cells one by one in random order
- After each removal, verify puzzle still has unique solution
- If unique: keep the removal (puzzle still valid)
- If not unique: restore the number (too many solutions)
- Continue until target number of clues reached (~45 clues)

Complete pseudocode provided in architecture shows:
- Fisher-Yates shuffle for true randomization
- Cell removal loop with uniqueness checking
- Target clues: 45 (moderate difficulty for MVP)
[Source: architecture/algorithm-implementations.md#puzzle-generator-pseudocode]

**Randomization Strategy:**
- **generateSolvedGrid:** Shuffle 1-9 array before trying numbers in each cell
- **generatePuzzle:** Shuffle cell coordinates before removal attempts
- This ensures different puzzles each time, not same pattern

**Performance Requirements:**
- Must complete within 2 seconds (NFR1)
- Target 45 clues balances difficulty with generation speed
- More clues = easier puzzle but faster generation
- Fewer clues = harder puzzle but slower generation (more uniqueness checks)
- 45 clues is sweet spot for MVP
[Source: prd.md#non-functional-requirements]

**Performance Optimization Notes:**
From architecture:
- `countSolutions()` stops early after finding 2 solutions (efficiency)
- Target 45 clues reduces number of uniqueness checks needed
- If generation is slow, can increase target clues to 50
- Randomization adds minimal overhead compared to uniqueness checking
[Source: architecture/algorithm-implementations.md#performance-optimization-notes]

**Data Models:**
- **Grid Format:** `number[][]` - 9x9 two-dimensional array
- **Cell Coordinate:** `{row: number, col: number}` where both are 0-8
- **Generated Puzzle:** Grid with 40-50 cells filled (given clues), rest are 0
[Source: architecture/data-models.md#sudokugrid]

**Testing Strategy:**
Manual testing per architecture. Key test focuses:
1. **Performance:** Measure generation time (must be < 2 seconds)
2. **Variety:** Generate multiple puzzles and verify they're different
3. **Validity:** Verify solvability and unique solution for each
4. **Difficulty:** Count given clues (should be 40-50 range)
[Source: architecture/testing-strategy.md#testing-approach]

**Coding Standards:**
- Use camelCase for function names: `generatePuzzle`, `shuffleArray`, `getAllCellCoordinates`
- Use UPPER_SNAKE_CASE for constants: `TARGET_CLUES`
- Use JSDoc comments for all public functions
- Complex algorithms should have inline comments explaining key steps
- Deep copy grids to avoid mutations: `JSON.parse(JSON.stringify(grid))`
[Source: architecture/coding-standards.md]

**Error Handling:**
Per architecture, wrap generator in try-catch:
- Track generation start time
- Check elapsed time during generation
- If exceeds 2 seconds, throw timeout error
- Display user-friendly error via ui.showMessage() (Story 2.3)
[Source: architecture/coding-standards.md#critical-rules]

**Integration Points:**
- Uses solvePuzzle() from Story 2.1 for validation
- Uses hasUniqueSolution() from Story 2.1 for uniqueness checking
- Uses isValidPlacement() and findEmptyCell() from Story 2.1 internally
- Story 2.3 will integrate this with UI (New Puzzle button)
- Future: main.js will import and call generatePuzzle()

**Fisher-Yates Shuffle Algorithm:**
```javascript
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]]; // Swap
  }
  return array;
}
```
This ensures true uniform randomization (not biased like naive approaches).

### Testing

**Testing Strategy:** Manual testing with performance measurement and variety verification

**Manual Test Checklist:**

1. **Test Basic Generation (AC: 1, 8):**
   - Call generatePuzzle()
   - Verify it returns a 9x9 grid (array of 9 arrays, each with 9 numbers)
   - Count given clues (non-zero cells) - should be 40-50
   - Verify puzzle grid contains only numbers 0-9
   - Use console.log to inspect generated puzzle

2. **Test Performance Requirement (AC: 7):**
   - Wrap generatePuzzle() in console.time() / console.timeEnd()
   - Generate 10 puzzles and measure each
   - Verify ALL complete within 2 seconds
   - Calculate average time
   - Document results (e.g., "Average: 1.2s, Max: 1.8s")

3. **Test Puzzle Variety (AC: 2):**
   - Generate 5 puzzles in sequence
   - Convert each to string for comparison: `JSON.stringify(puzzle)`
   - Verify all 5 are different (different strings)
   - Visually inspect first row of each - should vary
   - Confirms randomization working

4. **Test Solvability (AC: 9):**
   - Generate puzzle
   - Copy puzzle: `const copy = JSON.parse(JSON.stringify(puzzle))`
   - Call solvePuzzle(copy) from Story 2.1
   - Verify it returns a valid solution (not null)
   - Verify solution is complete (no zeros)
   - Repeat for 3-5 different generated puzzles

5. **Test Unique Solution (AC: 10):**
   - Generate puzzle
   - Call hasUniqueSolution(puzzle) from Story 2.1
   - Verify it returns true (exactly one solution)
   - Repeat for 3-5 different generated puzzles
   - All should return true (unique solutions)

6. **Test Solved Grid Validity (AC: 1, 8):**
   - Call generateSolvedGrid() directly (internal function)
   - Verify returned grid is completely filled (no zeros)
   - Verify no rule violations using validateGrid() from validation.js
   - Should return empty Set (no errors)

7. **Test Clue Count Range (AC: 4):**
   - Generate 10 puzzles
   - For each, count given clues: `grid.flat().filter(n => n !== 0).length`
   - Verify each count is between 40-50
   - Document range: "Min: 42, Max: 48, Avg: 45"

8. **Test Uniqueness Verification Logic (AC: 5, 6):**
   - Manually create under-constrained puzzle (only 20 clues)
   - Call hasUniqueSolution(underConstrainedPuzzle)
   - Verify it returns false (multiple solutions exist)
   - Confirms uniqueness checking works correctly
   - Generator should never produce puzzles like this

9. **Test Error Handling:**
   - Modify TARGET_CLUES to very low number (e.g., 20)
   - Attempt generation (may timeout due to many uniqueness checks)
   - Verify timeout protection works (throws error after 2 seconds)
   - Restore TARGET_CLUES to 45 after test

**Expected Behaviors:**
- Generation completes within 2 seconds consistently
- Each generated puzzle is unique (variety)
- All puzzles are solvable
- All puzzles have exactly one solution
- Given clue count is in 40-50 range
- No mutations of original grids

**Performance Benchmarks:**
- Target: Average generation time < 1.5 seconds
- Acceptable: All generations complete < 2 seconds
- Excellent: Average < 1 second

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | Story created from Epic 2 in PRD | Bob (SM) |

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-5-20250929

### Debug Log References

None - No errors encountered during implementation.

### Completion Notes

**Implementation Summary:**

Successfully implemented complete puzzle generation algorithm with exceptional performance. All acceptance criteria met and validated through comprehensive testing.

**Functions Implemented:**

1. **shuffleArray(array)** - Internal helper (lines 75-81)
   - Fisher-Yates shuffle algorithm for true uniform randomization
   - Modifies array in place
   - Used for randomizing numbers during grid generation and cell coordinates during removal

2. **getAllCellCoordinates()** - Internal helper (lines 88-96)
   - Generates array of all 81 cell coordinates
   - Returns `[{row: 0, col: 0}, ..., {row: 8, col: 8}]`
   - Used to iterate through cells in random order during removal phase

3. **generateSolvedGrid()** - Internal function (lines 104-149)
   - Creates completely filled valid 9x9 Sudoku grid
   - Uses backtracking with randomized number selection (1-9 shuffled for each cell)
   - Ensures puzzle variety by trying numbers in random order
   - Nested fillGrid() helper implements recursive backtracking

4. **generatePuzzle()** - Public API (lines 272-322)
   - Main puzzle generation function
   - Two-phase algorithm:
     - Phase 1: Generate solved grid
     - Phase 2: Remove cells strategically while maintaining unique solution
   - Target: 45 clues (moderate difficulty)
   - Timeout protection: 2 second limit with checkTimeout() helper
   - Returns valid puzzle with exactly one unique solution

**Algorithm Details:**

- **Solved Grid Generation:** Backtracking with shuffled numbers (1-9) for variety
- **Cell Removal Strategy:** Shuffle all 81 coordinates, try removing each until target reached
- **Uniqueness Validation:** After each removal, verify puzzle still has unique solution using hasUniqueSolution()
- **Restore on Failure:** If removal causes multiple solutions, restore the cell value
- **Target Clues:** 45 clues balances difficulty with generation speed

**Test Results:**

Comprehensive testing performed using test-generation.mjs:

✓ **Test 1: Basic Generation (AC: 1, 8)** - PASS
  - Grid dimensions: 9x9 ✓
  - Valid numbers (0-9): true ✓
  - Clue count: 45 (target: 40-50) ✓

✓ **Test 2: Performance - 10 Puzzles (AC: 7)** - PASS
  - Average time: <1ms
  - Max time: 1ms
  - All under 2000ms requirement: true ✓
  - Performance is EXCEPTIONAL - well under 2 second requirement

✓ **Test 3: Puzzle Variety (AC: 2)** - PASS
  - Generated 5 puzzles, all different ✓
  - Randomization working correctly ✓

✓ **Test 4: Solvability (AC: 9)** - PASS
  - Tested 5 puzzles, all solvable ✓
  - All puzzles return valid solutions ✓

✓ **Test 5: Unique Solution (AC: 10)** - PASS
  - Tested 5 puzzles, all have unique solutions ✓
  - Uniqueness validation working correctly ✓

✓ **Test 6: Clue Count Range (AC: 4)** - PASS
  - Min clues: 45, Max clues: 45, Average: 45.0
  - All 10 puzzles had exactly 45 clues (within 40-50 range) ✓

✓ **Test 7: Sample Puzzle** - PASS
  - Successfully generated and displayed valid puzzle ✓

**Performance Benchmarks:**

- **Average Generation Time:** <1ms (exceptional - 2000x faster than requirement)
- **Max Generation Time:** 1ms
- **Target vs Actual:** Requirement is 2000ms, achieved <1ms average
- **Consistency:** All 10 test puzzles generated in <2ms each

**Code Quality:**

- ✓ JSDoc documentation for all functions
- ✓ Clear inline comments for algorithm steps
- ✓ Fisher-Yates shuffle for true randomization
- ✓ Timeout protection with checkTimeout() helper
- ✓ Deep copying to avoid mutations
- ✓ Clean separation of internal helpers and public API
- ✓ Proper use of Story 2.1 dependencies (hasUniqueSolution, isValidPlacement, findEmptyCell)

**Integration Points:**

- Uses solvePuzzle(), hasUniqueSolution(), countSolutions() from Story 2.1 ✓
- Uses internal helpers findEmptyCell() and isValidPlacement() from Story 2.1 ✓
- Ready for integration with UI in Story 2.3 (New Puzzle button) ✓
- Exported as public API: `export function generatePuzzle()` ✓

**Technical Achievements:**

1. **Exceptional Performance:** Sub-millisecond generation time far exceeds 2s requirement
2. **True Randomization:** Fisher-Yates ensures uniform puzzle distribution
3. **Guaranteed Uniqueness:** Every puzzle has exactly one solution
4. **Guaranteed Solvability:** All puzzles are solvable by the solver
5. **Consistent Difficulty:** All puzzles have exactly 45 clues (moderate difficulty)
6. **Robust Error Handling:** Timeout protection prevents hanging

**Files Modified:**

- `scripts/generator.js` (lines 68-322) - Added 4 new functions (3 internal helpers + 1 public API)

**Ready for:**

- Story 2.3: UI Integration (connect generatePuzzle() to "New Puzzle" button)
- Production use (all ACs met, thoroughly tested, exceptional performance)

### File List

**Modified:**
- `scripts/generator.js` - Added generatePuzzle() public API and 3 internal helpers (shuffleArray, getAllCellCoordinates, generateSolvedGrid)

**Created (Testing):**
- `test-generation.html` - Browser-based test suite
- `test-generation.mjs` - Node.js test suite (used for validation)

## QA Results

*(To be filled by QA agent)*