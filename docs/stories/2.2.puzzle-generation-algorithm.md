# Story 2.2: Puzzle Generation Algorithm

## Status

Approved

## Story

**As a** developer,
**I want** an algorithm to generate valid Sudoku puzzles with unique solutions,
**so that** the application can create unlimited puzzles without hardcoded data.

## Acceptance Criteria

1. A generator function creates a valid, completely filled 9x9 Sudoku grid (solved puzzle)
2. The generator uses backtracking with randomized cell/number selection to ensure puzzle variety
3. The generator removes numbers from the solved grid to create the puzzle (leaving given clues)
4. The generator removes numbers strategically to achieve appropriate difficulty (approximately 40-50 clues remaining for MVP)
5. After each number removal, the generator verifies the puzzle still has a unique solution using the solver
6. If removing a number results in multiple solutions, that number is retained (not removed)
7. The generator completes within 2 seconds (per NFR1)
8. Generated puzzles are valid (all Sudoku rules satisfied in the solution)
9. Generated puzzles are solvable by the solver
10. Generated puzzles have exactly one unique solution

## Tasks / Subtasks

- [ ] Implement helper function: shuffleArray(array) (AC: 2)
  - [ ] Use Fisher-Yates shuffle algorithm for true randomization
  - [ ] Modify array in place
  - [ ] Return the shuffled array
  - [ ] Add JSDoc documentation

- [ ] Implement helper function: getAllCellCoordinates() (AC: 3)
  - [ ] Generate array of all 81 cell coordinates: `[{row: 0, col: 0}, {row: 0, col: 1}, ..., {row: 8, col: 8}]`
  - [ ] Use nested loops (row 0-8, col 0-8)
  - [ ] Return array of 81 coordinate objects
  - [ ] Add JSDoc documentation

- [ ] Implement generateSolvedGrid() function (AC: 1, 2, 8)
  - [ ] Create empty 9x9 grid: `Array.from({ length: 9 }, () => Array(9).fill(0))`
  - [ ] Implement fillGrid(grid) recursive helper using backtracking
  - [ ] Find empty cell using findEmptyCell() from Story 2.1
  - [ ] Create array [1,2,3,4,5,6,7,8,9] and shuffle it with shuffleArray()
  - [ ] Try each number in shuffled order
  - [ ] Use isValidPlacement() from Story 2.1 to check validity
  - [ ] Place number and recursively call fillGrid()
  - [ ] If successful, return true; if not, backtrack (set cell to 0)
  - [ ] Return the filled grid once complete
  - [ ] Add JSDoc documentation explaining randomization approach

- [ ] Implement main generatePuzzle() function (AC: 3, 4, 5, 6, 7, 10)
  - [ ] Step 1: Generate complete solved grid using generateSolvedGrid()
  - [ ] Step 2: Deep copy solved grid: `JSON.parse(JSON.stringify(solvedGrid))`
  - [ ] Step 3: Get all cell coordinates and shuffle using getAllCellCoordinates() + shuffleArray()
  - [ ] Step 4: Define target clues constant: `const TARGET_CLUES = 45;`
  - [ ] Step 5: Initialize clues counter: `let cluesRemaining = 81;`
  - [ ] Step 6: Loop through shuffled cell coordinates
  - [ ] Step 7: For each cell, if cluesRemaining <= TARGET_CLUES, break (target reached)
  - [ ] Step 8: Store cell value temporarily: `const removedValue = puzzleGrid[row][col];`
  - [ ] Step 9: Set cell to 0: `puzzleGrid[row][col] = 0;`
  - [ ] Step 10: Check uniqueness using hasUniqueSolution() from Story 2.1
  - [ ] Step 11: If unique solution still exists, keep removal (decrement cluesRemaining)
  - [ ] Step 12: If multiple solutions exist, restore value: `puzzleGrid[row][col] = removedValue;`
  - [ ] Step 13: Return the generated puzzle grid
  - [ ] Add JSDoc documentation with algorithm explanation

- [ ] Export generatePuzzle() as public API (AC: 1, 8, 9, 10)
  - [ ] Add export statement: `export function generatePuzzle() { ... }`
  - [ ] Ensure generateSolvedGrid() remains internal (not exported)
  - [ ] Keep helper functions internal (shuffleArray, getAllCellCoordinates)

- [ ] Add error handling and timeout protection (AC: 7)
  - [ ] Wrap generatePuzzle() in try-catch
  - [ ] Add timeout mechanism: track start time, check elapsed time periodically
  - [ ] If generation exceeds 2 seconds, throw error with message: "Puzzle generation timed out"
  - [ ] Provide fallback suggestion in error message or comments

- [ ] Manual testing and validation (AC: 1, 7, 8, 9, 10)
  - [ ] Test 1: Generate 5 puzzles and verify each completes within 2 seconds
  - [ ] Test 2: Verify each generated puzzle has ~40-50 given clues (count non-zero cells)
  - [ ] Test 3: Verify generated puzzles are different (compare grids)
  - [ ] Test 4: Verify each puzzle is solvable using solvePuzzle() from Story 2.1
  - [ ] Test 5: Verify each puzzle has unique solution using hasUniqueSolution() from Story 2.1
  - [ ] Test 6: Verify solved grid is valid (no rule violations in complete grid)
  - [ ] Test 7: Performance benchmark - measure average generation time over 10 puzzles
  - [ ] Document test results in Dev Agent Record section

## Dev Notes

### Architecture Context

**Depends on:** Story 2.1 (requires solvePuzzle(), hasUniqueSolution(), isValidPlacement(), findEmptyCell())

**Previous Story Insights:**
Story 2.1 implemented the backtracking solver in `scripts/generator.js` with:
- `solvePuzzle(grid)` - Solves puzzles using backtracking
- `hasUniqueSolution(grid)` - Verifies exactly one solution exists
- `countSolutions(grid, maxCount)` - Counts solutions with early exit
- `isValidPlacement(grid, row, col, num)` - Internal helper for validation
- `findEmptyCell(grid)` - Internal helper to find next empty cell

Story 2.2 will extend the same `generator.js` module with puzzle generation functions.

**File Location:**
Add functions to existing `scripts/generator.js` module created in Story 2.1.
[Source: architecture/source-tree.md#scripts-directory]

**Module Structure:**
```javascript
// generator.js - updated structure after Story 2.2
import { validateGrid } from './validation.js';

// Internal helpers from Story 2.1
function findEmptyCell(grid) { /* ... */ }
function isValidPlacement(grid, row, col, num) { /* ... */ }

// Story 2.1 public API
export function solvePuzzle(grid) { /* ... */ }
export function countSolutions(grid, maxCount) { /* ... */ }
export function hasUniqueSolution(grid) { /* ... */ }

// NEW Story 2.2 internal helpers
function shuffleArray(array) { /* ... */ }
function getAllCellCoordinates() { /* ... */ }
function generateSolvedGrid() { /* ... */ }

// NEW Story 2.2 public API
export function generatePuzzle() { /* ... */ }
```
[Source: architecture/source-tree.md#module-dependencies]

**Algorithm Implementation:**
The puzzle generation algorithm follows a two-phase approach:

**Phase 1: Generate Solved Grid**
- Start with empty 9x9 grid (all zeros)
- Use backtracking with randomized number selection
- Shuffle numbers 1-9 before trying each cell
- This ensures variety in generated puzzles
- Same backtracking logic as solver, but with randomization

**Phase 2: Remove Numbers Strategically**
- Start with complete solved grid (81 filled cells)
- Get all 81 cell coordinates and shuffle randomly
- Try removing cells one by one in random order
- After each removal, verify puzzle still has unique solution
- If unique: keep the removal (puzzle still valid)
- If not unique: restore the number (too many solutions)
- Continue until target number of clues reached (~45 clues)

Complete pseudocode provided in architecture shows:
- Fisher-Yates shuffle for true randomization
- Cell removal loop with uniqueness checking
- Target clues: 45 (moderate difficulty for MVP)
[Source: architecture/algorithm-implementations.md#puzzle-generator-pseudocode]

**Randomization Strategy:**
- **generateSolvedGrid:** Shuffle 1-9 array before trying numbers in each cell
- **generatePuzzle:** Shuffle cell coordinates before removal attempts
- This ensures different puzzles each time, not same pattern

**Performance Requirements:**
- Must complete within 2 seconds (NFR1)
- Target 45 clues balances difficulty with generation speed
- More clues = easier puzzle but faster generation
- Fewer clues = harder puzzle but slower generation (more uniqueness checks)
- 45 clues is sweet spot for MVP
[Source: prd.md#non-functional-requirements]

**Performance Optimization Notes:**
From architecture:
- `countSolutions()` stops early after finding 2 solutions (efficiency)
- Target 45 clues reduces number of uniqueness checks needed
- If generation is slow, can increase target clues to 50
- Randomization adds minimal overhead compared to uniqueness checking
[Source: architecture/algorithm-implementations.md#performance-optimization-notes]

**Data Models:**
- **Grid Format:** `number[][]` - 9x9 two-dimensional array
- **Cell Coordinate:** `{row: number, col: number}` where both are 0-8
- **Generated Puzzle:** Grid with 40-50 cells filled (given clues), rest are 0
[Source: architecture/data-models.md#sudokugrid]

**Testing Strategy:**
Manual testing per architecture. Key test focuses:
1. **Performance:** Measure generation time (must be < 2 seconds)
2. **Variety:** Generate multiple puzzles and verify they're different
3. **Validity:** Verify solvability and unique solution for each
4. **Difficulty:** Count given clues (should be 40-50 range)
[Source: architecture/testing-strategy.md#testing-approach]

**Coding Standards:**
- Use camelCase for function names: `generatePuzzle`, `shuffleArray`, `getAllCellCoordinates`
- Use UPPER_SNAKE_CASE for constants: `TARGET_CLUES`
- Use JSDoc comments for all public functions
- Complex algorithms should have inline comments explaining key steps
- Deep copy grids to avoid mutations: `JSON.parse(JSON.stringify(grid))`
[Source: architecture/coding-standards.md]

**Error Handling:**
Per architecture, wrap generator in try-catch:
- Track generation start time
- Check elapsed time during generation
- If exceeds 2 seconds, throw timeout error
- Display user-friendly error via ui.showMessage() (Story 2.3)
[Source: architecture/coding-standards.md#critical-rules]

**Integration Points:**
- Uses solvePuzzle() from Story 2.1 for validation
- Uses hasUniqueSolution() from Story 2.1 for uniqueness checking
- Uses isValidPlacement() and findEmptyCell() from Story 2.1 internally
- Story 2.3 will integrate this with UI (New Puzzle button)
- Future: main.js will import and call generatePuzzle()

**Fisher-Yates Shuffle Algorithm:**
```javascript
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]]; // Swap
  }
  return array;
}
```
This ensures true uniform randomization (not biased like naive approaches).

### Testing

**Testing Strategy:** Manual testing with performance measurement and variety verification

**Manual Test Checklist:**

1. **Test Basic Generation (AC: 1, 8):**
   - Call generatePuzzle()
   - Verify it returns a 9x9 grid (array of 9 arrays, each with 9 numbers)
   - Count given clues (non-zero cells) - should be 40-50
   - Verify puzzle grid contains only numbers 0-9
   - Use console.log to inspect generated puzzle

2. **Test Performance Requirement (AC: 7):**
   - Wrap generatePuzzle() in console.time() / console.timeEnd()
   - Generate 10 puzzles and measure each
   - Verify ALL complete within 2 seconds
   - Calculate average time
   - Document results (e.g., "Average: 1.2s, Max: 1.8s")

3. **Test Puzzle Variety (AC: 2):**
   - Generate 5 puzzles in sequence
   - Convert each to string for comparison: `JSON.stringify(puzzle)`
   - Verify all 5 are different (different strings)
   - Visually inspect first row of each - should vary
   - Confirms randomization working

4. **Test Solvability (AC: 9):**
   - Generate puzzle
   - Copy puzzle: `const copy = JSON.parse(JSON.stringify(puzzle))`
   - Call solvePuzzle(copy) from Story 2.1
   - Verify it returns a valid solution (not null)
   - Verify solution is complete (no zeros)
   - Repeat for 3-5 different generated puzzles

5. **Test Unique Solution (AC: 10):**
   - Generate puzzle
   - Call hasUniqueSolution(puzzle) from Story 2.1
   - Verify it returns true (exactly one solution)
   - Repeat for 3-5 different generated puzzles
   - All should return true (unique solutions)

6. **Test Solved Grid Validity (AC: 1, 8):**
   - Call generateSolvedGrid() directly (internal function)
   - Verify returned grid is completely filled (no zeros)
   - Verify no rule violations using validateGrid() from validation.js
   - Should return empty Set (no errors)

7. **Test Clue Count Range (AC: 4):**
   - Generate 10 puzzles
   - For each, count given clues: `grid.flat().filter(n => n !== 0).length`
   - Verify each count is between 40-50
   - Document range: "Min: 42, Max: 48, Avg: 45"

8. **Test Uniqueness Verification Logic (AC: 5, 6):**
   - Manually create under-constrained puzzle (only 20 clues)
   - Call hasUniqueSolution(underConstrainedPuzzle)
   - Verify it returns false (multiple solutions exist)
   - Confirms uniqueness checking works correctly
   - Generator should never produce puzzles like this

9. **Test Error Handling:**
   - Modify TARGET_CLUES to very low number (e.g., 20)
   - Attempt generation (may timeout due to many uniqueness checks)
   - Verify timeout protection works (throws error after 2 seconds)
   - Restore TARGET_CLUES to 45 after test

**Expected Behaviors:**
- Generation completes within 2 seconds consistently
- Each generated puzzle is unique (variety)
- All puzzles are solvable
- All puzzles have exactly one solution
- Given clue count is in 40-50 range
- No mutations of original grids

**Performance Benchmarks:**
- Target: Average generation time < 1.5 seconds
- Acceptable: All generations complete < 2 seconds
- Excellent: Average < 1 second

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | Story created from Epic 2 in PRD | Bob (SM) |

## Dev Agent Record

### Agent Model Used

*(To be filled by dev agent)*

### Debug Log References

*(To be filled by dev agent)*

### Completion Notes

*(To be filled by dev agent)*

### File List

*(To be filled by dev agent)*

## QA Results

*(To be filled by QA agent)*