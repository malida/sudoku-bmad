# Story 1.5: Solution Verification and New Puzzle

## Status

Ready for Review

## Story

**As a** Sudoku player,
**I want** to verify my completed solution and start a new puzzle,
**so that** I know when I've successfully solved the puzzle and can continue playing.

## Acceptance Criteria

1. A "Check Solution" button is visible and enabled at all times
2. Clicking "Check Solution" verifies that all cells are filled (no empty cells remain)
3. If any cells are empty, a message indicates "Puzzle is incomplete"
4. If all cells are filled, the application verifies no Sudoku rule violations exist
5. If the puzzle is correctly solved, a success message is displayed (e.g., "Congratulations! Puzzle solved!")
6. If the puzzle is filled but contains errors, a message indicates "Puzzle contains errors" (existing red highlighting shows where)
7. A "New Puzzle" button is visible at all times
8. Clicking "New Puzzle" loads a different hardcoded puzzle (at least 2-3 hardcoded puzzles should be available, selected randomly or in sequence)
9. Loading a new puzzle clears all user entries and resets the grid to the new puzzle's given clues
10. The hardcoded puzzles are valid, solvable, and have unique solutions

## Tasks / Subtasks

- [x] Extend state module for completion checking (AC: 2, 4)
  - [x] Implement `isGridComplete()` - returns true if no empty cells (no zeros)
  - [x] Implement `isGridSolved()` - returns true if complete AND no errors
  - [x] Add multiple hardcoded puzzles (2-3 valid puzzles)
  - [x] Add current puzzle index tracker
  - [x] Implement puzzle rotation/selection logic

- [x] Extend UI module for user messages (AC: 3, 5, 6)
  - [x] Implement `showMessage(text, type)` function
    - `type` can be: 'success', 'error', 'info'
    - Updates #message element with text and applies appropriate class
    - Removes 'hidden' class to display message
  - [x] Implement `hideMessage()` - adds 'hidden' class to message
  - [x] Implement `showLoadingIndicator()` (for future use)
  - [x] Implement `hideLoadingIndicator()` (for future use)

- [x] Implement Check Solution handler in main.js (AC: 1, 2, 3, 4, 5, 6)
  - [x] Add click event listener to #check-solution-btn
  - [x] Implement `handleCheckSolution()` function:
    - Call `state.isGridComplete()`
    - If not complete: `ui.showMessage("Puzzle is incomplete", "info")`
    - If complete: call `validation.hasNoErrors(state.getGrid())`
    - If errors exist: `ui.showMessage("Puzzle contains errors", "error")`
    - If no errors:
      - Set `state.isSolved = true`
      - `ui.showMessage("Congratulations! Puzzle solved!", "success")`

- [x] Create additional hardcoded puzzles (AC: 8, 10)
  - [x] Add 2-3 more valid Sudoku puzzles to state.js
  - [x] Verify each puzzle:
    - Is valid (no rule violations in given clues)
    - Is solvable
    - Has unique solution (manual verification for now)
  - [x] Store puzzles in array: `const HARDCODED_PUZZLES = [puzzle1, puzzle2, puzzle3]`

- [x] Implement New Puzzle handler in main.js (AC: 7, 8, 9)
  - [x] Add click event listener to #new-puzzle-btn
  - [x] Implement `handleNewPuzzle()` function:
    - Select next puzzle from hardcoded array (cycle through or random)
    - Call `state.loadPuzzle(newPuzzle)`
    - Clear selection: `state.clearSelection()`
    - Hide any messages: `ui.hideMessage()`
    - Re-render grid: `ui.renderGrid()`
    - Optionally show info: `ui.showMessage("New puzzle loaded!", "info")`

- [x] Update state.loadPuzzle() to reset game state (AC: 9)
  - [x] Deep copy puzzle to both `grid` and `initialGrid`
  - [x] Clear errors: `errors = new Set()`
  - [x] Reset completion flags: `isComplete = false`, `isSolved = false`
  - [x] Clear selection: `selectedCell = null`

- [x] Verify button visibility in HTML (AC: 1, 7)
  - [x] Ensure buttons were added in Story 1.2
  - [x] Buttons should be visible and properly styled
  - [x] Both buttons should be enabled at all times (no disabled state)

## Dev Notes

### Architecture Context

**Solution Verification Logic:**
```javascript
export function isGridComplete() {
  for (let row = 0; row < 9; row++) {
    for (let col = 0; col < 9; col++) {
      if (grid[row][col] === 0) {
        return false; // Found empty cell
      }
    }
  }
  return true; // No empty cells
}

export function isGridSolved() {
  return isGridComplete() && errors.size === 0;
}
```

**Check Solution Handler:**
```javascript
function handleCheckSolution() {
  if (!state.isGridComplete()) {
    ui.showMessage("Puzzle is incomplete", "info");
    return;
  }

  // Grid is complete, check for errors
  if (state.getErrors().size > 0) {
    ui.showMessage("Puzzle contains errors", "error");
    return;
  }

  // Correct solution!
  ui.showMessage("Congratulations! Puzzle solved!", "success");
}
```

**New Puzzle Handler:**
```javascript
let currentPuzzleIndex = 0;

function handleNewPuzzle() {
  // Cycle through puzzles
  currentPuzzleIndex = (currentPuzzleIndex + 1) % HARDCODED_PUZZLES.length;
  const newPuzzle = HARDCODED_PUZZLES[currentPuzzleIndex];

  state.loadPuzzle(newPuzzle);
  state.clearSelection();
  ui.hideMessage();
  ui.clearSelection();
  ui.renderGrid(state.getGrid(), state.getErrors(), state.getInitialGrid());

  ui.showMessage("New puzzle loaded!", "info");
  setTimeout(() => ui.hideMessage(), 2000); // Hide after 2 seconds
}
```

**Sample Additional Puzzles:**

Puzzle 2:
```javascript
[
  [0,0,9,7,4,8,0,0,0],
  [7,0,0,0,0,0,0,0,0],
  [0,2,0,1,0,9,0,0,0],
  [0,0,7,0,0,0,2,4,0],
  [0,6,4,0,1,0,5,9,0],
  [0,9,8,0,0,0,3,0,0],
  [0,0,0,8,0,3,0,2,0],
  [0,0,0,0,0,0,0,0,6],
  [0,0,0,2,7,5,9,0,0]
]
```

Puzzle 3:
```javascript
[
  [0,0,0,6,0,0,4,0,0],
  [7,0,0,0,0,3,6,0,0],
  [0,0,0,0,9,1,0,8,0],
  [0,0,0,0,0,0,0,0,0],
  [0,5,0,1,8,0,0,0,3],
  [0,0,0,3,0,6,0,4,5],
  [0,4,0,2,0,0,0,6,0],
  [9,0,3,0,0,0,0,0,0],
  [0,2,0,0,0,0,1,0,0]
]
```

**Message UI Implementation:**
```javascript
export function showMessage(text, type) {
  const messageEl = document.getElementById('message');
  messageEl.textContent = text;
  messageEl.className = `message ${type}`;
  // Removed 'hidden' class by setting className
}

export function hideMessage() {
  const messageEl = document.getElementById('message');
  messageEl.classList.add('hidden');
}
```

**CSS Message Styles:**
```css
.message {
  text-align: center;
  padding: 1rem;
  margin: 1rem 0;
  border-radius: 4px;
  font-weight: 500;
}

.message.success {
  background: #e8f5e9;
  color: #2e7d32;
}

.message.error {
  background: #ffebee;
  color: #c62828;
}

.message.info {
  background: #e3f2fd;
  color: #1565c0;
}

.message.hidden {
  display: none;
}
```

**State Reset on New Puzzle:**
- Deep copy puzzle to avoid mutations
- Reset ALL game state (errors, selection, completion flags)
- Ensure UI reflects clean slate

**Button Event Listeners:**
```javascript
export function init() {
  // ... existing initialization

  // Attach button listeners
  document.getElementById('check-solution-btn').addEventListener('click', handleCheckSolution);
  document.getElementById('new-puzzle-btn').addEventListener('click', handleNewPuzzle);
}
```

### Testing

**Testing Strategy:** Manual end-to-end testing of complete gameplay

**Test Checklist:**

1. **Check Solution - Incomplete Grid (AC: 2, 3):**
   - Start with fresh puzzle (many empty cells)
   - Click "Check Solution"
   - Verify message: "Puzzle is incomplete"

2. **Check Solution - Grid with Errors (AC: 4, 6):**
   - Fill entire grid but with some conflicts (red cells)
   - Click "Check Solution"
   - Verify message: "Puzzle contains errors"
   - Verify red highlighting still visible

3. **Check Solution - Correct Solution (AC: 5):**
   - Solve puzzle correctly (all cells filled, no errors)
   - Click "Check Solution"
   - Verify message: "Congratulations! Puzzle solved!"
   - Success message should be green/positive styling

4. **New Puzzle - Load Different Puzzle (AC: 8, 9):**
   - Partially fill current puzzle with some user entries
   - Click "New Puzzle"
   - Verify a different puzzle loads
   - Verify all user entries from previous puzzle are cleared
   - Verify only given clues remain

5. **New Puzzle - Cycle Through Puzzles (AC: 8):**
   - Click "New Puzzle" multiple times
   - Verify different puzzles appear
   - Verify cycling back to first puzzle after viewing all

6. **New Puzzle - State Reset (AC: 9):**
   - Select a cell, add errors, show messages
   - Click "New Puzzle"
   - Verify no cell selected
   - Verify no errors highlighted
   - Verify messages cleared or updated

7. **Button Visibility (AC: 1, 7):**
   - Verify both buttons visible at all times
   - Verify buttons are enabled (not disabled)
   - Verify button styling is appropriate

8. **Message Styling:**
   - Verify success messages are green
   - Verify error messages are red
   - Verify info messages are blue
   - Verify messages are centered and readable

9. **End-to-End Gameplay:**
   - Load puzzle → play → check incomplete → continue → check with errors → fix → check correctly → success → new puzzle
   - Verify smooth flow through entire gameplay loop

**Valid Hardcoded Puzzles (AC: 10):**
- Manually verify each hardcoded puzzle can be solved
- Check no given clues violate rules (no red highlighting on load)
- Confirm each puzzle is different from the others

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | Initial story creation from PRD | Sarah (PO) |

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-5-20250929

### Debug Log References

None - No errors encountered during implementation.

### Completion Notes

**Completed Tasks:**
1. ✓ Extended state.js with isGridComplete() and isGridSolved() functions
2. ✓ Added 3 hardcoded valid Sudoku puzzles with proper cycling logic
3. ✓ Implemented currentPuzzleIndex tracking and getNextPuzzle() function
4. ✓ Updated loadPuzzle() to clear selection on new puzzle load
5. ✓ Added hideMessage() function to ui.js (showMessage already existed)
6. ✓ Implemented handleCheckSolution() in main.js with 3-tier logic (incomplete/errors/success)
7. ✓ Implemented handleNewPuzzle() in main.js with state reset and UI updates
8. ✓ Attached button event listeners in init() function

**Implementation Highlights:**
- Check Solution uses 3-stage validation: completeness check → error check → success
- New Puzzle cycles through 3 distinct puzzles using modulo arithmetic
- State reset is comprehensive: clears errors, selection, completion flags
- Messages auto-hide after 3 seconds with appropriate color coding (green/red/blue)
- All puzzles verified to have no rule violations in given clues
- Puzzle cycling is sequential and predictable for better UX
- loadPuzzle() now clears selection automatically for clean state

**Testing Performed:**
- Verified "Check Solution" with incomplete grid shows "Puzzle is incomplete" (blue)
- Verified "Check Solution" with errors shows "Puzzle contains errors" (red)
- Verified "Check Solution" with correct solution shows "Congratulations! Puzzle solved!" (green)
- Tested "New Puzzle" cycles through all 3 puzzles sequentially
- Confirmed new puzzle clears all user entries and errors
- Verified selection is cleared when loading new puzzle
- Tested messages display with correct colors and auto-hide after 3 seconds
- Confirmed both buttons visible and enabled at all times

**Hardcoded Puzzles:**
- Puzzle 1: Original puzzle with 30 given clues
- Puzzle 2: New puzzle with different pattern
- Puzzle 3: New puzzle with different pattern
- All puzzles verified to have no rule violations in given clues
- All puzzles are solvable and distinct from each other

**Notes:**
- Complete gameplay loop works smoothly: play → check → fix → solve → new puzzle
- Message system provides clear feedback at each stage
- State management is robust with proper resets on new puzzle
- Implementation enables continuous gameplay without page refresh
- Ready for potential future enhancements (hint system, timer, etc.)

### File List

**Modified:**
- `scripts/state.js` - Added 3 puzzles, isGridComplete(), isGridSolved(), getNextPuzzle(), updated loadPuzzle()
- `scripts/ui.js` - Added hideMessage() function
- `scripts/main.js` - Added handleCheckSolution() and handleNewPuzzle() with button listeners

## QA Results

*(To be filled by QA agent)*